<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>SFSORT API documentation</title>
<meta name="description" content="This module contains the SFSORT object detection tracker
implementation. By introducing a novel cost function called
the Bounding Box Similarity â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SFSORT</code></h1>
</header>
<section id="section-intro">
<p>This module contains the SFSORT object detection tracker
implementation. By introducing a novel cost function called
the Bounding Box Similarity Index, this project eliminates
the Kalman Filter, leading to reduced computational requirements.</p>
<h2 id="quickstart">Quickstart</h2>
<p>There are two files available for a quickstart with this tracker:</p>
<ul>
<li>
<p>through ONNX model in form of YOLOv7 <a href="https://github.com/Applied-Deep-Learning-Lab/SFSORT/blob/main/yolov7_onnxruntime_sfsort.py">here</a>.</p>
</li>
<li>
<p>for any model in Ultralytics framework <a href="https://github.com/Applied-Deep-Learning-Lab/SFSORT/blob/main/yolov7_onnxruntime_sfsort.py">here</a>.</p>
</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Simply import the module in your Python code:</p>
<pre><code>from SFSORT import SFSORT
</code></pre>
<p>Initialize the tracker:</p>
<pre><code># Organize tracker arguments into standard format
tracker_arguments = {"dynamic_tuning": True, "cth": 0.7,
                    "high_th": 0.7, "high_th_m": 0.1,
                    "match_th_first": 0.6, "match_th_first_m": 0.05,
                    "match_th_second": 0.4, "low_th": 0.2,
                    "new_track_th": 0.5, "new_track_th_m": 0.1,
                    "marginal_timeout": (7 * fps // 10),
                    "central_timeout": fps,
                    "horizontal_margin": width // 10,
                    "vertical_margin": height // 10,
                    "frame_width": width,
                    "frame_height": height,}
# Instantiate a tracker
tracker = SFSORT(tracker_arguments)
</code></pre>
<p>The parameters for the tracker are as follows:</p>
<ul>
<li><code>cth</code>
Threshold that determines the number of set members whose detection score exceeds this value</li>
<li><code>high_th</code>
Minimum score for high-score detections</li>
<li><strong><code>low_th</code></strong>
Minimum score for intermediate-score detections</li>
<li><code>match_th_first</code>
Maximum allowable cost in the first association module</li>
<li><strong><code>match_th_second</code></strong> Maximum allowable cost in the second association module</li>
<li><code>new_track_th</code>
Minimum score for detections identified as new tracks</li>
<li><code>horizontal_margin</code>
Margin to determine the horizontal boundaries of central areas</li>
<li><code>vertical_margin</code>
Margin to determine the vertical boundaries of central areas</li>
<li><code>central_timeout</code>
Time-out for tracks lost at central areas</li>
<li><code>marginal_timeout</code>
Time-out for tracks lost at marginal areas</li>
</ul>
<p>Parameters in bold are the most important and should be modified based on the detector being used.
For example, YOLOv10 might give low scores to small objects while Unet doesn't and thus <code>low_th</code>
should be set lower for the former.
Parameters with <code>_m</code> suffix are margins that are being used with <code>dynamic_tuning</code> key. Basically if
your detector is being used in an environment with a lot of occlusions/disocclusions/overlap it might
be better to leave this parameter turned on. It should dynamically change threshold values when the
detector is confused in crowded environments or rapidly moving objects. In other cases you can turn it off.</p>
<p>After that simply pass three arrays, containing bounding boxes, confidence and classes values.</p>
<pre><code># Update the tracker with the latest detections
tracks = tracker.update(
    prediction_results.xyxy,
    prediction_results.conf,
    prediction_results.cls)
</code></pre>
<p>As a response you will get an array with track IDs and your input values. Be aware that all values are in <code>np.float32</code>.</p>
<pre><code># Extract tracking data from the tracker
bbox_list      = tracks[:, 0]
track_id_list  = tracks[:, 1]
cls_id_list    = tracks[:, 2]
scores_list    = tracks[:, 3]
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module contains the SFSORT object detection tracker
implementation. By introducing a novel cost function called
the Bounding Box Similarity Index, this project eliminates
the Kalman Filter, leading to reduced computational requirements.

.. include:: ./docs/documentation.md
&#34;&#34;&#34;
import numpy as np

# It is best to use (lapjv)[https://github.com/gatagat/lap]
# since the time to solve the linear assignment problem
# is the shortest for this implementation
use_lap=True
try:
    import lap
except ImportError:
    from scipy.optimize import linear_sum_assignment
    use_lap=False


class DotAccess(dict):
    &#34;&#34;&#34;
    Provides dot.notation access to dictionary attributes

    Parameters
    ----------
    dict : dictionary
        The dictionary to access with dot notation

    Examples
    --------
    &gt;&gt;&gt; d = DotAccess({&#39;a&#39;: 1, &#39;b&#39;: 2})
    &gt;&gt;&gt; d.a
    1
    &gt;&gt;&gt; d.b
    2
    &#34;&#34;&#34;
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__


class TrackState:
    &#34;&#34;&#34;
    Enumeration of possible states of a track

    Attributes
    ----------
    Active : int
        The track is active
    Lost_Central : int
        The track is lost in the central region
    Lost_Marginal : int
        The track is lost in the marginal region
    &#34;&#34;&#34;
    Active = 0
    Lost_Central = 1
    Lost_Marginal = 2


class Track:
    &#34;&#34;&#34;
    Handles basic track attributes and operations

    Parameters
    ----------
    bbox : array_like
        The bounding box of the track
    frame_id : int
        The frame ID of the track
    track_id : int
        The track ID
    cls_id : int
        The class ID of the track
    score : float
        The score of the track

    Attributes
    ----------
    track_id : int
        The track ID
    bbox : array_like
        The bounding box of the track
    cls_id : int
        The class ID of the track
    score : float
        The score of the track
    state : int
        The state of the track (active, lost central, or lost marginal)
    last_frame : int
        The last frame ID of the track

    Examples
    --------
    &gt;&gt;&gt; track = Track([1, 2, 3, 4], 0, 0, 0, 0.5)
    &gt;&gt;&gt; track.update([5, 6, 7, 8], 1, 1, 0.8)
    &gt;&gt;&gt; track.bbox
    [5, 6, 7, 8]
    &gt;&gt;&gt; track.score
    0.8
    &#34;&#34;&#34;
    def __init__(self, bbox, frame_id, track_id, cls_id, score):
        self.track_id = track_id
        self.update(bbox, frame_id, cls_id, score)
        self.state = TrackState.Active

    def update(self, bbox, frame_id, cls_id, score):
        &#34;&#34;&#34;Updates a matched track&#34;&#34;&#34;
        self.bbox = bbox
        self.cls_id = cls_id
        self.score = score
        self.state = TrackState.Active
        self.last_frame = frame_id


class SFSORT:
    &#34;&#34;&#34;
    Multi-Object Tracking System

    Parameters
    ----------
    args : dictionary
        The arguments for the tracker

    Attributes
    ----------
    frame_no : int
        The current frame number
    id_counter : int
        The track ID counter
    active_tracks : list
        The list of active tracks
    lost_tracks : list
        The list of lost tracks

    Examples
    --------
    &gt;&gt;&gt; tracker = SFSORT({&#39;low_th&#39;: 0.5, &#39;match_th_second&#39;: 0.7})
    &gt;&gt;&gt; tracks = tracker.update([[124, 112, 327, 450], [234, 56, 261, 563]],
                                [0.8, 0.9],
                                [0, 1])
    &gt;&gt;&gt; bbox_list      = tracks[:, 0]
    &gt;&gt;&gt; track_id_list  = tracks[:, 1]
    &gt;&gt;&gt; cls_id_list    = tracks[:, 2]
    &gt;&gt;&gt; scores_list    = tracks[:, 3]
    &#34;&#34;&#34;

    def __init__(self, args):
        # Initialize tracker&#39;s arguments
        self.update_args(args)

        # Initialize the tracker
        self.frame_no = 0
        self.id_counter = 0
        self.active_tracks = []
        self.lost_tracks = []

    def update_args(self, args):
        &#34;&#34;&#34;Updates tracker&#39;s arguments

        Parameters
        ----------
        args : dict
            Tracker parameters
        &#34;&#34;&#34;
        args = DotAccess(args)
        # Register tracking arguments

        self.low_th = args.low_th
        self.match_th_second = args.match_th_second

        self.high_th = args.high_th
        self.match_th_first = args.match_th_first
        self.new_track_th = args.new_track_th

        if args.dynamic_tuning:
            self.cth = args.cth if args.cth else 0.7
            self.hthm = args.high_th_m if args.high_th_m else 0
            self.nthm = args.new_track_th_m if args.new_track_th_m else 0
            self.mthm = args.match_th_first_m if args.match_th_first_m else 0


        self.marginal_timeout = args.marginal_timeout
        self.central_timeout = args.central_timeout
        self.l_margin = args.horizontal_margin
        self.t_margin = args.vertical_margin
        self.r_margin = args.frame_width - args.horizontal_margin
        self.b_margin = args.frame_height - args.vertical_margin

    def update(self, boxes, scores, class_ids):
        &#34;&#34;&#34;Updates tracker with new detections

        Parameters
        ----------
        boxes : array
            Bounding boxes coordinates
        scores : array
            Neural network confidence values
        class_ids: array
            Detected class for an object
        Returns
        -------
        result : array
            All of the inputs plus track IDs for actively tracked objects
        &#34;&#34;&#34;
        # Adjust dynamic arguments
        count = len(scores[scores&gt;self.cth])

        if count &lt; 1:
          count = 1

        lnc = np.log10(count)
        hth = self.high_th - (self.hthm * lnc)
        nth = self.new_track_th + (self.nthm * lnc)
        mth = self.match_th_first - (self.mthm * lnc)

        # Increase frame number
        self.frame_no += 1

        # Variable: Active tracks in the next frame
        next_active_tracks = []

        # Remove long-time lost tracks
        for track in self.lost_tracks:
            if track.state == TrackState.Lost_Central:
                if self.frame_no - track.last_frame &gt; self.central_timeout:
                    self.lost_tracks.remove(track)
                    del track
            else:
                if self.frame_no - track.last_frame &gt; self.marginal_timeout:
                    self.lost_tracks.remove(track)
                    del track

        # Gather out all previous tracks
        track_pool = self.active_tracks + self.lost_tracks

        # Try to associate tracks with high score detections
        unmatched_tracks = np.array([])
        high_score = scores &gt; hth
        if high_score.any():
            definite_boxes = boxes[high_score]
            definite_scores = scores[high_score]
            definite_classes = class_ids[high_score]
            if track_pool:
                cost = self.calculate_cost(track_pool, definite_boxes)
                matches, unmatched_tracks, unmatched_detections = self.linear_assignment(cost, mth)
                # Update/Activate matched tracks
                for track_idx, detection_idx in matches:
                    box = definite_boxes[detection_idx]
                    class_id = definite_classes[detection_idx]
                    score = definite_scores[detection_idx]
                    track = track_pool[track_idx]
                    track.update(box, self.frame_no, class_id, score)
                    next_active_tracks.append(track)
                    # Remove re-identified tracks from lost list
                    if track in self.lost_tracks:
                        self.lost_tracks.remove(track)
                # Identify eligible unmatched detections as new tracks
                for detection_idx in unmatched_detections:
                    if definite_scores[detection_idx] &gt; nth:
                        box = definite_boxes[detection_idx]
                        class_id = definite_classes[detection_idx]
                        score = definite_scores[detection_idx]
                        track = Track(box, self.frame_no, self.id_counter, class_id, score)
                        next_active_tracks.append(track)
                        self.id_counter += 1
            else:
                # Associate tracks of the first frame after object-free/null frames
                for detection_idx, score in enumerate(definite_scores):
                    if score &gt; nth:
                        box = definite_boxes[detection_idx]
                        class_id = definite_classes[detection_idx]
                        score = definite_scores[detection_idx]
                        track = Track(box, self.frame_no, self.id_counter, class_id, score)
                        next_active_tracks.append(track)
                        self.id_counter += 1

        # Add unmatched tracks to the lost list
        unmatched_track_pool = []
        for track_address in unmatched_tracks:
            unmatched_track_pool.append(track_pool[track_address])
        next_lost_tracks = unmatched_track_pool.copy()

        # Try to associate remained tracks with intermediate score detections
        intermediate_score = np.logical_and((self.low_th &lt; scores), (scores &lt; hth))
        if intermediate_score.any():
            if len(unmatched_tracks):
                possible_boxes = boxes[intermediate_score]
                possible_class_ids = class_ids[intermediate_score]
                possible_scores = scores[intermediate_score]
                cost = self.calculate_cost(unmatched_track_pool, possible_boxes, iou_only=True)
                matches, unmatched_tracks, unmatched_detections = self.linear_assignment(cost, self.match_th_second)
                # Update/Activate matched tracks
                for track_idx, detection_idx in matches:
                    box = possible_boxes[detection_idx]
                    class_id = possible_class_ids[detection_idx]
                    score = possible_scores[detection_idx]
                    track = unmatched_track_pool[track_idx]
                    track.update(box, self.frame_no, class_id, score)
                    next_active_tracks.append(track)
                    # Remove re-identified tracks from lost list
                    if track in self.lost_tracks:
                        self.lost_tracks.remove(track)
                    next_lost_tracks.remove(track)

        # All tracks are lost if there are no detections!
        if not (high_score.any() or  intermediate_score.any()):
            next_lost_tracks = track_pool.copy()

        # Update the list of lost tracks
        for track in next_lost_tracks:
            if track not in self.lost_tracks:
                self.lost_tracks.append(track)
                u = track.bbox[0] + (track.bbox[2] - track.bbox[0]/2)
                v = track.bbox[1] + (track.bbox[3] - track.bbox[1]/2)
                if (self.l_margin &lt; u &lt; self.r_margin) and (self.t_margin &lt; v &lt; self.b_margin):
                    track.state = TrackState.Lost_Central
                else:
                    track.state = TrackState.Lost_Marginal

        # Update the list of active tracks
        self.active_tracks = next_active_tracks.copy()

        result = np.asarray([
            [x.bbox, x.track_id, x.cls_id, round(x.score, 2)]
            for x in next_active_tracks],
            dtype=object)

        return result

    @staticmethod
    def calculate_cost(tracks, boxes, iou_only=False):
        &#34;&#34;&#34;
        Calculates the association cost based on IoU and box similarity

        Parameters
        ----------
        tracks : list
            The list of tracks
        boxes : array_like
            The list of bounding boxes
        iou_only : bool, optional
            Whether to calculate IoU only (default is False)

        Returns
        -------
        cost_matrix : array
            The association cost matrix
        &#34;&#34;&#34;
        eps = 1e-7
        active_boxes = [track.bbox for track in tracks]

        # Get the coordinates of bounding boxes
        b1_x1, b1_y1, b1_x2, b1_y2 = np.array(active_boxes).T
        b2_x1, b2_y1, b2_x2, b2_y2 = np.array(boxes).T

        h_intersection = (np.minimum(b1_x2[:, None], b2_x2) - np.maximum(b1_x1[:, None], b2_x1)).clip(0)
        w_intersection = (np.minimum(b1_y2[:, None], b2_y2) - np.maximum(b1_y1[:, None], b2_y1)).clip(0)

        # Calculate the intersection area
        intersection =  h_intersection * w_intersection

        # Calculate the union area
        box1_height = b1_x2 - b1_x1
        box2_height = b2_x2 - b2_x1
        box1_width = b1_y2 - b1_y1
        box2_width = b2_y2 - b2_y1

        box1_area = box1_height * box1_width
        box2_area = box2_height * box2_width

        union = (box2_area + box1_area[:, None] - intersection + eps)

        # Calculate the IoU
        iou = intersection / union

        if iou_only:
            return 1.0 - iou

        # Calculate the DIoU
        centerx1 = (b1_x1 + b1_x2) / 2.0
        centery1 = (b1_y1 + b1_y2) / 2.0
        centerx2 = (b2_x1 + b2_x2) / 2.0
        centery2 = (b2_y1 + b2_y2) / 2.0
        inner_diag = np.abs(centerx1[:, None] - centerx2) + np.abs(centery1[:, None] - centery2)

        xxc1 = np.minimum(b1_x1[:, None], b2_x1)
        yyc1 = np.minimum(b1_y1[:, None], b2_y1)
        xxc2 = np.maximum(b1_x2[:, None], b2_x2)
        yyc2 = np.maximum(b1_y2[:, None], b2_y2)
        outer_diag = np.abs(xxc2 - xxc1) + np.abs(yyc2 - yyc1)

        diou = iou - (inner_diag / outer_diag)

        # Calculate the BBSI
        delta_w = np.abs(box2_width - box1_width[:, None])
        sw = w_intersection / np.abs(w_intersection + delta_w + eps)

        delta_h = np.abs(box2_height - box1_height[:, None])
        sh = h_intersection / np.abs(h_intersection + delta_h + eps)

        bbsi = diou + sh + sw

        # Normalize the BBSI
        cost = (bbsi)/3.0

        return 1.0 - cost


    @staticmethod
    def linear_assignment(cost_matrix, thresh):
        &#34;&#34;&#34;
        Linear assignment

        Parameters
        ----------
        cost_matrix : array
            The association cost matrix
        thresh : float
            The threshold for the linear assignment

        Returns
        -------
        matches : array
            The matched indices
        unmatched_tracks : tuple
            The unmatched track indices
        unmatched_detections : tuple
            The unmatched detection indices
        &#34;&#34;&#34;
        if cost_matrix.size == 0:
            return np.empty((0, 2), dtype=int), tuple(range(cost_matrix.shape[0])), tuple(range(cost_matrix.shape[1]))

        if use_lap:
            _, x, y = lap.lapjv(cost_matrix, extend_cost=True, cost_limit=thresh)
            matches = [[ix, mx] for ix, mx in enumerate(x) if mx &gt;= 0]
            unmatched_a = np.where(x &lt; 0)[0]
            unmatched_b = np.where(y &lt; 0)[0]
        else:
            y, x = linear_sum_assignment(cost_matrix)
            matches = np.asarray([[i, x] for i, x in enumerate(x) if cost_matrix[i, x] &lt;= thresh])
            unmatched = np.ones(cost_matrix.shape)
            for i, xi in matches:
                unmatched[i, xi] = 0.0
            unmatched_a = np.where(unmatched.all(1))[0]
            unmatched_b = np.where(unmatched.all(0))[0]

        return matches, unmatched_a, unmatched_b</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="SFSORT.DotAccess"><code class="flex name class">
<span>class <span class="ident">DotAccess</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides dot.notation access to dictionary attributes</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dict</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>The dictionary to access with dot notation</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; d = DotAccess({'a': 1, 'b': 2})
&gt;&gt;&gt; d.a
1
&gt;&gt;&gt; d.b
2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DotAccess(dict):
    &#34;&#34;&#34;
    Provides dot.notation access to dictionary attributes

    Parameters
    ----------
    dict : dictionary
        The dictionary to access with dot notation

    Examples
    --------
    &gt;&gt;&gt; d = DotAccess({&#39;a&#39;: 1, &#39;b&#39;: 2})
    &gt;&gt;&gt; d.a
    1
    &gt;&gt;&gt; d.b
    2
    &#34;&#34;&#34;
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
<dt id="SFSORT.SFSORT"><code class="flex name class">
<span>class <span class="ident">SFSORT</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Multi-Object Tracking System</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>The arguments for the tracker</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>frame_no</code></strong> :&ensp;<code>int</code></dt>
<dd>The current frame number</dd>
<dt><strong><code>id_counter</code></strong> :&ensp;<code>int</code></dt>
<dd>The track ID counter</dd>
<dt><strong><code>active_tracks</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of active tracks</dd>
<dt><strong><code>lost_tracks</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of lost tracks</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; tracker = SFSORT({'low_th': 0.5, 'match_th_second': 0.7})
&gt;&gt;&gt; tracks = tracker.update([[124, 112, 327, 450], [234, 56, 261, 563]],
                            [0.8, 0.9],
                            [0, 1])
&gt;&gt;&gt; bbox_list      = tracks[:, 0]
&gt;&gt;&gt; track_id_list  = tracks[:, 1]
&gt;&gt;&gt; cls_id_list    = tracks[:, 2]
&gt;&gt;&gt; scores_list    = tracks[:, 3]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SFSORT:
    &#34;&#34;&#34;
    Multi-Object Tracking System

    Parameters
    ----------
    args : dictionary
        The arguments for the tracker

    Attributes
    ----------
    frame_no : int
        The current frame number
    id_counter : int
        The track ID counter
    active_tracks : list
        The list of active tracks
    lost_tracks : list
        The list of lost tracks

    Examples
    --------
    &gt;&gt;&gt; tracker = SFSORT({&#39;low_th&#39;: 0.5, &#39;match_th_second&#39;: 0.7})
    &gt;&gt;&gt; tracks = tracker.update([[124, 112, 327, 450], [234, 56, 261, 563]],
                                [0.8, 0.9],
                                [0, 1])
    &gt;&gt;&gt; bbox_list      = tracks[:, 0]
    &gt;&gt;&gt; track_id_list  = tracks[:, 1]
    &gt;&gt;&gt; cls_id_list    = tracks[:, 2]
    &gt;&gt;&gt; scores_list    = tracks[:, 3]
    &#34;&#34;&#34;

    def __init__(self, args):
        # Initialize tracker&#39;s arguments
        self.update_args(args)

        # Initialize the tracker
        self.frame_no = 0
        self.id_counter = 0
        self.active_tracks = []
        self.lost_tracks = []

    def update_args(self, args):
        &#34;&#34;&#34;Updates tracker&#39;s arguments

        Parameters
        ----------
        args : dict
            Tracker parameters
        &#34;&#34;&#34;
        args = DotAccess(args)
        # Register tracking arguments

        self.low_th = args.low_th
        self.match_th_second = args.match_th_second

        self.high_th = args.high_th
        self.match_th_first = args.match_th_first
        self.new_track_th = args.new_track_th

        if args.dynamic_tuning:
            self.cth = args.cth if args.cth else 0.7
            self.hthm = args.high_th_m if args.high_th_m else 0
            self.nthm = args.new_track_th_m if args.new_track_th_m else 0
            self.mthm = args.match_th_first_m if args.match_th_first_m else 0


        self.marginal_timeout = args.marginal_timeout
        self.central_timeout = args.central_timeout
        self.l_margin = args.horizontal_margin
        self.t_margin = args.vertical_margin
        self.r_margin = args.frame_width - args.horizontal_margin
        self.b_margin = args.frame_height - args.vertical_margin

    def update(self, boxes, scores, class_ids):
        &#34;&#34;&#34;Updates tracker with new detections

        Parameters
        ----------
        boxes : array
            Bounding boxes coordinates
        scores : array
            Neural network confidence values
        class_ids: array
            Detected class for an object
        Returns
        -------
        result : array
            All of the inputs plus track IDs for actively tracked objects
        &#34;&#34;&#34;
        # Adjust dynamic arguments
        count = len(scores[scores&gt;self.cth])

        if count &lt; 1:
          count = 1

        lnc = np.log10(count)
        hth = self.high_th - (self.hthm * lnc)
        nth = self.new_track_th + (self.nthm * lnc)
        mth = self.match_th_first - (self.mthm * lnc)

        # Increase frame number
        self.frame_no += 1

        # Variable: Active tracks in the next frame
        next_active_tracks = []

        # Remove long-time lost tracks
        for track in self.lost_tracks:
            if track.state == TrackState.Lost_Central:
                if self.frame_no - track.last_frame &gt; self.central_timeout:
                    self.lost_tracks.remove(track)
                    del track
            else:
                if self.frame_no - track.last_frame &gt; self.marginal_timeout:
                    self.lost_tracks.remove(track)
                    del track

        # Gather out all previous tracks
        track_pool = self.active_tracks + self.lost_tracks

        # Try to associate tracks with high score detections
        unmatched_tracks = np.array([])
        high_score = scores &gt; hth
        if high_score.any():
            definite_boxes = boxes[high_score]
            definite_scores = scores[high_score]
            definite_classes = class_ids[high_score]
            if track_pool:
                cost = self.calculate_cost(track_pool, definite_boxes)
                matches, unmatched_tracks, unmatched_detections = self.linear_assignment(cost, mth)
                # Update/Activate matched tracks
                for track_idx, detection_idx in matches:
                    box = definite_boxes[detection_idx]
                    class_id = definite_classes[detection_idx]
                    score = definite_scores[detection_idx]
                    track = track_pool[track_idx]
                    track.update(box, self.frame_no, class_id, score)
                    next_active_tracks.append(track)
                    # Remove re-identified tracks from lost list
                    if track in self.lost_tracks:
                        self.lost_tracks.remove(track)
                # Identify eligible unmatched detections as new tracks
                for detection_idx in unmatched_detections:
                    if definite_scores[detection_idx] &gt; nth:
                        box = definite_boxes[detection_idx]
                        class_id = definite_classes[detection_idx]
                        score = definite_scores[detection_idx]
                        track = Track(box, self.frame_no, self.id_counter, class_id, score)
                        next_active_tracks.append(track)
                        self.id_counter += 1
            else:
                # Associate tracks of the first frame after object-free/null frames
                for detection_idx, score in enumerate(definite_scores):
                    if score &gt; nth:
                        box = definite_boxes[detection_idx]
                        class_id = definite_classes[detection_idx]
                        score = definite_scores[detection_idx]
                        track = Track(box, self.frame_no, self.id_counter, class_id, score)
                        next_active_tracks.append(track)
                        self.id_counter += 1

        # Add unmatched tracks to the lost list
        unmatched_track_pool = []
        for track_address in unmatched_tracks:
            unmatched_track_pool.append(track_pool[track_address])
        next_lost_tracks = unmatched_track_pool.copy()

        # Try to associate remained tracks with intermediate score detections
        intermediate_score = np.logical_and((self.low_th &lt; scores), (scores &lt; hth))
        if intermediate_score.any():
            if len(unmatched_tracks):
                possible_boxes = boxes[intermediate_score]
                possible_class_ids = class_ids[intermediate_score]
                possible_scores = scores[intermediate_score]
                cost = self.calculate_cost(unmatched_track_pool, possible_boxes, iou_only=True)
                matches, unmatched_tracks, unmatched_detections = self.linear_assignment(cost, self.match_th_second)
                # Update/Activate matched tracks
                for track_idx, detection_idx in matches:
                    box = possible_boxes[detection_idx]
                    class_id = possible_class_ids[detection_idx]
                    score = possible_scores[detection_idx]
                    track = unmatched_track_pool[track_idx]
                    track.update(box, self.frame_no, class_id, score)
                    next_active_tracks.append(track)
                    # Remove re-identified tracks from lost list
                    if track in self.lost_tracks:
                        self.lost_tracks.remove(track)
                    next_lost_tracks.remove(track)

        # All tracks are lost if there are no detections!
        if not (high_score.any() or  intermediate_score.any()):
            next_lost_tracks = track_pool.copy()

        # Update the list of lost tracks
        for track in next_lost_tracks:
            if track not in self.lost_tracks:
                self.lost_tracks.append(track)
                u = track.bbox[0] + (track.bbox[2] - track.bbox[0]/2)
                v = track.bbox[1] + (track.bbox[3] - track.bbox[1]/2)
                if (self.l_margin &lt; u &lt; self.r_margin) and (self.t_margin &lt; v &lt; self.b_margin):
                    track.state = TrackState.Lost_Central
                else:
                    track.state = TrackState.Lost_Marginal

        # Update the list of active tracks
        self.active_tracks = next_active_tracks.copy()

        result = np.asarray([
            [x.bbox, x.track_id, x.cls_id, round(x.score, 2)]
            for x in next_active_tracks],
            dtype=object)

        return result

    @staticmethod
    def calculate_cost(tracks, boxes, iou_only=False):
        &#34;&#34;&#34;
        Calculates the association cost based on IoU and box similarity

        Parameters
        ----------
        tracks : list
            The list of tracks
        boxes : array_like
            The list of bounding boxes
        iou_only : bool, optional
            Whether to calculate IoU only (default is False)

        Returns
        -------
        cost_matrix : array
            The association cost matrix
        &#34;&#34;&#34;
        eps = 1e-7
        active_boxes = [track.bbox for track in tracks]

        # Get the coordinates of bounding boxes
        b1_x1, b1_y1, b1_x2, b1_y2 = np.array(active_boxes).T
        b2_x1, b2_y1, b2_x2, b2_y2 = np.array(boxes).T

        h_intersection = (np.minimum(b1_x2[:, None], b2_x2) - np.maximum(b1_x1[:, None], b2_x1)).clip(0)
        w_intersection = (np.minimum(b1_y2[:, None], b2_y2) - np.maximum(b1_y1[:, None], b2_y1)).clip(0)

        # Calculate the intersection area
        intersection =  h_intersection * w_intersection

        # Calculate the union area
        box1_height = b1_x2 - b1_x1
        box2_height = b2_x2 - b2_x1
        box1_width = b1_y2 - b1_y1
        box2_width = b2_y2 - b2_y1

        box1_area = box1_height * box1_width
        box2_area = box2_height * box2_width

        union = (box2_area + box1_area[:, None] - intersection + eps)

        # Calculate the IoU
        iou = intersection / union

        if iou_only:
            return 1.0 - iou

        # Calculate the DIoU
        centerx1 = (b1_x1 + b1_x2) / 2.0
        centery1 = (b1_y1 + b1_y2) / 2.0
        centerx2 = (b2_x1 + b2_x2) / 2.0
        centery2 = (b2_y1 + b2_y2) / 2.0
        inner_diag = np.abs(centerx1[:, None] - centerx2) + np.abs(centery1[:, None] - centery2)

        xxc1 = np.minimum(b1_x1[:, None], b2_x1)
        yyc1 = np.minimum(b1_y1[:, None], b2_y1)
        xxc2 = np.maximum(b1_x2[:, None], b2_x2)
        yyc2 = np.maximum(b1_y2[:, None], b2_y2)
        outer_diag = np.abs(xxc2 - xxc1) + np.abs(yyc2 - yyc1)

        diou = iou - (inner_diag / outer_diag)

        # Calculate the BBSI
        delta_w = np.abs(box2_width - box1_width[:, None])
        sw = w_intersection / np.abs(w_intersection + delta_w + eps)

        delta_h = np.abs(box2_height - box1_height[:, None])
        sh = h_intersection / np.abs(h_intersection + delta_h + eps)

        bbsi = diou + sh + sw

        # Normalize the BBSI
        cost = (bbsi)/3.0

        return 1.0 - cost


    @staticmethod
    def linear_assignment(cost_matrix, thresh):
        &#34;&#34;&#34;
        Linear assignment

        Parameters
        ----------
        cost_matrix : array
            The association cost matrix
        thresh : float
            The threshold for the linear assignment

        Returns
        -------
        matches : array
            The matched indices
        unmatched_tracks : tuple
            The unmatched track indices
        unmatched_detections : tuple
            The unmatched detection indices
        &#34;&#34;&#34;
        if cost_matrix.size == 0:
            return np.empty((0, 2), dtype=int), tuple(range(cost_matrix.shape[0])), tuple(range(cost_matrix.shape[1]))

        if use_lap:
            _, x, y = lap.lapjv(cost_matrix, extend_cost=True, cost_limit=thresh)
            matches = [[ix, mx] for ix, mx in enumerate(x) if mx &gt;= 0]
            unmatched_a = np.where(x &lt; 0)[0]
            unmatched_b = np.where(y &lt; 0)[0]
        else:
            y, x = linear_sum_assignment(cost_matrix)
            matches = np.asarray([[i, x] for i, x in enumerate(x) if cost_matrix[i, x] &lt;= thresh])
            unmatched = np.ones(cost_matrix.shape)
            for i, xi in matches:
                unmatched[i, xi] = 0.0
            unmatched_a = np.where(unmatched.all(1))[0]
            unmatched_b = np.where(unmatched.all(0))[0]

        return matches, unmatched_a, unmatched_b</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="SFSORT.SFSORT.calculate_cost"><code class="name flex">
<span>def <span class="ident">calculate_cost</span></span>(<span>tracks, boxes, iou_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the association cost based on IoU and box similarity</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tracks</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of tracks</dd>
<dt><strong><code>boxes</code></strong> :&ensp;<code>array_like</code></dt>
<dd>The list of bounding boxes</dd>
<dt><strong><code>iou_only</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to calculate IoU only (default is False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cost_matrix</code></strong> :&ensp;<code>array</code></dt>
<dd>The association cost matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calculate_cost(tracks, boxes, iou_only=False):
    &#34;&#34;&#34;
    Calculates the association cost based on IoU and box similarity

    Parameters
    ----------
    tracks : list
        The list of tracks
    boxes : array_like
        The list of bounding boxes
    iou_only : bool, optional
        Whether to calculate IoU only (default is False)

    Returns
    -------
    cost_matrix : array
        The association cost matrix
    &#34;&#34;&#34;
    eps = 1e-7
    active_boxes = [track.bbox for track in tracks]

    # Get the coordinates of bounding boxes
    b1_x1, b1_y1, b1_x2, b1_y2 = np.array(active_boxes).T
    b2_x1, b2_y1, b2_x2, b2_y2 = np.array(boxes).T

    h_intersection = (np.minimum(b1_x2[:, None], b2_x2) - np.maximum(b1_x1[:, None], b2_x1)).clip(0)
    w_intersection = (np.minimum(b1_y2[:, None], b2_y2) - np.maximum(b1_y1[:, None], b2_y1)).clip(0)

    # Calculate the intersection area
    intersection =  h_intersection * w_intersection

    # Calculate the union area
    box1_height = b1_x2 - b1_x1
    box2_height = b2_x2 - b2_x1
    box1_width = b1_y2 - b1_y1
    box2_width = b2_y2 - b2_y1

    box1_area = box1_height * box1_width
    box2_area = box2_height * box2_width

    union = (box2_area + box1_area[:, None] - intersection + eps)

    # Calculate the IoU
    iou = intersection / union

    if iou_only:
        return 1.0 - iou

    # Calculate the DIoU
    centerx1 = (b1_x1 + b1_x2) / 2.0
    centery1 = (b1_y1 + b1_y2) / 2.0
    centerx2 = (b2_x1 + b2_x2) / 2.0
    centery2 = (b2_y1 + b2_y2) / 2.0
    inner_diag = np.abs(centerx1[:, None] - centerx2) + np.abs(centery1[:, None] - centery2)

    xxc1 = np.minimum(b1_x1[:, None], b2_x1)
    yyc1 = np.minimum(b1_y1[:, None], b2_y1)
    xxc2 = np.maximum(b1_x2[:, None], b2_x2)
    yyc2 = np.maximum(b1_y2[:, None], b2_y2)
    outer_diag = np.abs(xxc2 - xxc1) + np.abs(yyc2 - yyc1)

    diou = iou - (inner_diag / outer_diag)

    # Calculate the BBSI
    delta_w = np.abs(box2_width - box1_width[:, None])
    sw = w_intersection / np.abs(w_intersection + delta_w + eps)

    delta_h = np.abs(box2_height - box1_height[:, None])
    sh = h_intersection / np.abs(h_intersection + delta_h + eps)

    bbsi = diou + sh + sw

    # Normalize the BBSI
    cost = (bbsi)/3.0

    return 1.0 - cost</code></pre>
</details>
</dd>
<dt id="SFSORT.SFSORT.linear_assignment"><code class="name flex">
<span>def <span class="ident">linear_assignment</span></span>(<span>cost_matrix, thresh)</span>
</code></dt>
<dd>
<div class="desc"><p>Linear assignment</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cost_matrix</code></strong> :&ensp;<code>array</code></dt>
<dd>The association cost matrix</dd>
<dt><strong><code>thresh</code></strong> :&ensp;<code>float</code></dt>
<dd>The threshold for the linear assignment</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>matches</code></strong> :&ensp;<code>array</code></dt>
<dd>The matched indices</dd>
<dt><strong><code>unmatched_tracks</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The unmatched track indices</dd>
<dt><strong><code>unmatched_detections</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The unmatched detection indices</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def linear_assignment(cost_matrix, thresh):
    &#34;&#34;&#34;
    Linear assignment

    Parameters
    ----------
    cost_matrix : array
        The association cost matrix
    thresh : float
        The threshold for the linear assignment

    Returns
    -------
    matches : array
        The matched indices
    unmatched_tracks : tuple
        The unmatched track indices
    unmatched_detections : tuple
        The unmatched detection indices
    &#34;&#34;&#34;
    if cost_matrix.size == 0:
        return np.empty((0, 2), dtype=int), tuple(range(cost_matrix.shape[0])), tuple(range(cost_matrix.shape[1]))

    if use_lap:
        _, x, y = lap.lapjv(cost_matrix, extend_cost=True, cost_limit=thresh)
        matches = [[ix, mx] for ix, mx in enumerate(x) if mx &gt;= 0]
        unmatched_a = np.where(x &lt; 0)[0]
        unmatched_b = np.where(y &lt; 0)[0]
    else:
        y, x = linear_sum_assignment(cost_matrix)
        matches = np.asarray([[i, x] for i, x in enumerate(x) if cost_matrix[i, x] &lt;= thresh])
        unmatched = np.ones(cost_matrix.shape)
        for i, xi in matches:
            unmatched[i, xi] = 0.0
        unmatched_a = np.where(unmatched.all(1))[0]
        unmatched_b = np.where(unmatched.all(0))[0]

    return matches, unmatched_a, unmatched_b</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="SFSORT.SFSORT.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, boxes, scores, class_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates tracker with new detections</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>boxes</code></strong> :&ensp;<code>array</code></dt>
<dd>Bounding boxes coordinates</dd>
<dt><strong><code>scores</code></strong> :&ensp;<code>array</code></dt>
<dd>Neural network confidence values</dd>
<dt><strong><code>class_ids</code></strong> :&ensp;<code>array</code></dt>
<dd>Detected class for an object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>array</code></dt>
<dd>All of the inputs plus track IDs for actively tracked objects</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, boxes, scores, class_ids):
    &#34;&#34;&#34;Updates tracker with new detections

    Parameters
    ----------
    boxes : array
        Bounding boxes coordinates
    scores : array
        Neural network confidence values
    class_ids: array
        Detected class for an object
    Returns
    -------
    result : array
        All of the inputs plus track IDs for actively tracked objects
    &#34;&#34;&#34;
    # Adjust dynamic arguments
    count = len(scores[scores&gt;self.cth])

    if count &lt; 1:
      count = 1

    lnc = np.log10(count)
    hth = self.high_th - (self.hthm * lnc)
    nth = self.new_track_th + (self.nthm * lnc)
    mth = self.match_th_first - (self.mthm * lnc)

    # Increase frame number
    self.frame_no += 1

    # Variable: Active tracks in the next frame
    next_active_tracks = []

    # Remove long-time lost tracks
    for track in self.lost_tracks:
        if track.state == TrackState.Lost_Central:
            if self.frame_no - track.last_frame &gt; self.central_timeout:
                self.lost_tracks.remove(track)
                del track
        else:
            if self.frame_no - track.last_frame &gt; self.marginal_timeout:
                self.lost_tracks.remove(track)
                del track

    # Gather out all previous tracks
    track_pool = self.active_tracks + self.lost_tracks

    # Try to associate tracks with high score detections
    unmatched_tracks = np.array([])
    high_score = scores &gt; hth
    if high_score.any():
        definite_boxes = boxes[high_score]
        definite_scores = scores[high_score]
        definite_classes = class_ids[high_score]
        if track_pool:
            cost = self.calculate_cost(track_pool, definite_boxes)
            matches, unmatched_tracks, unmatched_detections = self.linear_assignment(cost, mth)
            # Update/Activate matched tracks
            for track_idx, detection_idx in matches:
                box = definite_boxes[detection_idx]
                class_id = definite_classes[detection_idx]
                score = definite_scores[detection_idx]
                track = track_pool[track_idx]
                track.update(box, self.frame_no, class_id, score)
                next_active_tracks.append(track)
                # Remove re-identified tracks from lost list
                if track in self.lost_tracks:
                    self.lost_tracks.remove(track)
            # Identify eligible unmatched detections as new tracks
            for detection_idx in unmatched_detections:
                if definite_scores[detection_idx] &gt; nth:
                    box = definite_boxes[detection_idx]
                    class_id = definite_classes[detection_idx]
                    score = definite_scores[detection_idx]
                    track = Track(box, self.frame_no, self.id_counter, class_id, score)
                    next_active_tracks.append(track)
                    self.id_counter += 1
        else:
            # Associate tracks of the first frame after object-free/null frames
            for detection_idx, score in enumerate(definite_scores):
                if score &gt; nth:
                    box = definite_boxes[detection_idx]
                    class_id = definite_classes[detection_idx]
                    score = definite_scores[detection_idx]
                    track = Track(box, self.frame_no, self.id_counter, class_id, score)
                    next_active_tracks.append(track)
                    self.id_counter += 1

    # Add unmatched tracks to the lost list
    unmatched_track_pool = []
    for track_address in unmatched_tracks:
        unmatched_track_pool.append(track_pool[track_address])
    next_lost_tracks = unmatched_track_pool.copy()

    # Try to associate remained tracks with intermediate score detections
    intermediate_score = np.logical_and((self.low_th &lt; scores), (scores &lt; hth))
    if intermediate_score.any():
        if len(unmatched_tracks):
            possible_boxes = boxes[intermediate_score]
            possible_class_ids = class_ids[intermediate_score]
            possible_scores = scores[intermediate_score]
            cost = self.calculate_cost(unmatched_track_pool, possible_boxes, iou_only=True)
            matches, unmatched_tracks, unmatched_detections = self.linear_assignment(cost, self.match_th_second)
            # Update/Activate matched tracks
            for track_idx, detection_idx in matches:
                box = possible_boxes[detection_idx]
                class_id = possible_class_ids[detection_idx]
                score = possible_scores[detection_idx]
                track = unmatched_track_pool[track_idx]
                track.update(box, self.frame_no, class_id, score)
                next_active_tracks.append(track)
                # Remove re-identified tracks from lost list
                if track in self.lost_tracks:
                    self.lost_tracks.remove(track)
                next_lost_tracks.remove(track)

    # All tracks are lost if there are no detections!
    if not (high_score.any() or  intermediate_score.any()):
        next_lost_tracks = track_pool.copy()

    # Update the list of lost tracks
    for track in next_lost_tracks:
        if track not in self.lost_tracks:
            self.lost_tracks.append(track)
            u = track.bbox[0] + (track.bbox[2] - track.bbox[0]/2)
            v = track.bbox[1] + (track.bbox[3] - track.bbox[1]/2)
            if (self.l_margin &lt; u &lt; self.r_margin) and (self.t_margin &lt; v &lt; self.b_margin):
                track.state = TrackState.Lost_Central
            else:
                track.state = TrackState.Lost_Marginal

    # Update the list of active tracks
    self.active_tracks = next_active_tracks.copy()

    result = np.asarray([
        [x.bbox, x.track_id, x.cls_id, round(x.score, 2)]
        for x in next_active_tracks],
        dtype=object)

    return result</code></pre>
</details>
</dd>
<dt id="SFSORT.SFSORT.update_args"><code class="name flex">
<span>def <span class="ident">update_args</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates tracker's arguments</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>dict</code></dt>
<dd>Tracker parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_args(self, args):
    &#34;&#34;&#34;Updates tracker&#39;s arguments

    Parameters
    ----------
    args : dict
        Tracker parameters
    &#34;&#34;&#34;
    args = DotAccess(args)
    # Register tracking arguments

    self.low_th = args.low_th
    self.match_th_second = args.match_th_second

    self.high_th = args.high_th
    self.match_th_first = args.match_th_first
    self.new_track_th = args.new_track_th

    if args.dynamic_tuning:
        self.cth = args.cth if args.cth else 0.7
        self.hthm = args.high_th_m if args.high_th_m else 0
        self.nthm = args.new_track_th_m if args.new_track_th_m else 0
        self.mthm = args.match_th_first_m if args.match_th_first_m else 0


    self.marginal_timeout = args.marginal_timeout
    self.central_timeout = args.central_timeout
    self.l_margin = args.horizontal_margin
    self.t_margin = args.vertical_margin
    self.r_margin = args.frame_width - args.horizontal_margin
    self.b_margin = args.frame_height - args.vertical_margin</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="SFSORT.Track"><code class="flex name class">
<span>class <span class="ident">Track</span></span>
<span>(</span><span>bbox, frame_id, track_id, cls_id, score)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles basic track attributes and operations</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bbox</code></strong> :&ensp;<code>array_like</code></dt>
<dd>The bounding box of the track</dd>
<dt><strong><code>frame_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The frame ID of the track</dd>
<dt><strong><code>track_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The track ID</dd>
<dt><strong><code>cls_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The class ID of the track</dd>
<dt><strong><code>score</code></strong> :&ensp;<code>float</code></dt>
<dd>The score of the track</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>track_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The track ID</dd>
<dt><strong><code>bbox</code></strong> :&ensp;<code>array_like</code></dt>
<dd>The bounding box of the track</dd>
<dt><strong><code>cls_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The class ID of the track</dd>
<dt><strong><code>score</code></strong> :&ensp;<code>float</code></dt>
<dd>The score of the track</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>int</code></dt>
<dd>The state of the track (active, lost central, or lost marginal)</dd>
<dt><strong><code>last_frame</code></strong> :&ensp;<code>int</code></dt>
<dd>The last frame ID of the track</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; track = Track([1, 2, 3, 4], 0, 0, 0, 0.5)
&gt;&gt;&gt; track.update([5, 6, 7, 8], 1, 1, 0.8)
&gt;&gt;&gt; track.bbox
[5, 6, 7, 8]
&gt;&gt;&gt; track.score
0.8
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Track:
    &#34;&#34;&#34;
    Handles basic track attributes and operations

    Parameters
    ----------
    bbox : array_like
        The bounding box of the track
    frame_id : int
        The frame ID of the track
    track_id : int
        The track ID
    cls_id : int
        The class ID of the track
    score : float
        The score of the track

    Attributes
    ----------
    track_id : int
        The track ID
    bbox : array_like
        The bounding box of the track
    cls_id : int
        The class ID of the track
    score : float
        The score of the track
    state : int
        The state of the track (active, lost central, or lost marginal)
    last_frame : int
        The last frame ID of the track

    Examples
    --------
    &gt;&gt;&gt; track = Track([1, 2, 3, 4], 0, 0, 0, 0.5)
    &gt;&gt;&gt; track.update([5, 6, 7, 8], 1, 1, 0.8)
    &gt;&gt;&gt; track.bbox
    [5, 6, 7, 8]
    &gt;&gt;&gt; track.score
    0.8
    &#34;&#34;&#34;
    def __init__(self, bbox, frame_id, track_id, cls_id, score):
        self.track_id = track_id
        self.update(bbox, frame_id, cls_id, score)
        self.state = TrackState.Active

    def update(self, bbox, frame_id, cls_id, score):
        &#34;&#34;&#34;Updates a matched track&#34;&#34;&#34;
        self.bbox = bbox
        self.cls_id = cls_id
        self.score = score
        self.state = TrackState.Active
        self.last_frame = frame_id</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="SFSORT.Track.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, bbox, frame_id, cls_id, score)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates a matched track</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, bbox, frame_id, cls_id, score):
    &#34;&#34;&#34;Updates a matched track&#34;&#34;&#34;
    self.bbox = bbox
    self.cls_id = cls_id
    self.score = score
    self.state = TrackState.Active
    self.last_frame = frame_id</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="SFSORT.TrackState"><code class="flex name class">
<span>class <span class="ident">TrackState</span></span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of possible states of a track</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>Active</code></strong> :&ensp;<code>int</code></dt>
<dd>The track is active</dd>
<dt><strong><code>Lost_Central</code></strong> :&ensp;<code>int</code></dt>
<dd>The track is lost in the central region</dd>
<dt><strong><code>Lost_Marginal</code></strong> :&ensp;<code>int</code></dt>
<dd>The track is lost in the marginal region</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TrackState:
    &#34;&#34;&#34;
    Enumeration of possible states of a track

    Attributes
    ----------
    Active : int
        The track is active
    Lost_Central : int
        The track is lost in the central region
    Lost_Marginal : int
        The track is lost in the marginal region
    &#34;&#34;&#34;
    Active = 0
    Lost_Central = 1
    Lost_Marginal = 2</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="SFSORT.TrackState.Active"><code class="name">var <span class="ident">Active</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SFSORT.TrackState.Lost_Central"><code class="name">var <span class="ident">Lost_Central</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="SFSORT.TrackState.Lost_Marginal"><code class="name">var <span class="ident">Lost_Marginal</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#quickstart">Quickstart</a></li>
<li><a href="#usage">Usage</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="SFSORT.DotAccess" href="#SFSORT.DotAccess">DotAccess</a></code></h4>
</li>
<li>
<h4><code><a title="SFSORT.SFSORT" href="#SFSORT.SFSORT">SFSORT</a></code></h4>
<ul class="">
<li><code><a title="SFSORT.SFSORT.calculate_cost" href="#SFSORT.SFSORT.calculate_cost">calculate_cost</a></code></li>
<li><code><a title="SFSORT.SFSORT.linear_assignment" href="#SFSORT.SFSORT.linear_assignment">linear_assignment</a></code></li>
<li><code><a title="SFSORT.SFSORT.update" href="#SFSORT.SFSORT.update">update</a></code></li>
<li><code><a title="SFSORT.SFSORT.update_args" href="#SFSORT.SFSORT.update_args">update_args</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="SFSORT.Track" href="#SFSORT.Track">Track</a></code></h4>
<ul class="">
<li><code><a title="SFSORT.Track.update" href="#SFSORT.Track.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="SFSORT.TrackState" href="#SFSORT.TrackState">TrackState</a></code></h4>
<ul class="">
<li><code><a title="SFSORT.TrackState.Active" href="#SFSORT.TrackState.Active">Active</a></code></li>
<li><code><a title="SFSORT.TrackState.Lost_Central" href="#SFSORT.TrackState.Lost_Central">Lost_Central</a></code></li>
<li><code><a title="SFSORT.TrackState.Lost_Marginal" href="#SFSORT.TrackState.Lost_Marginal">Lost_Marginal</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>